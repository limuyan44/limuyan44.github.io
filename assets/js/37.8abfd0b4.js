(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{535:function(e,a,t){"use strict";t.r(a);var n=t(6),r=Object(n.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"实现类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现类"}},[e._v("#")]),e._v(" 实现类")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('package com.csii.ifp.action;\n\npublic class HelloWorld {\n    public String sayHello(){\n        return "Hello World!";\n    }\n}\n')])])]),t("h2",{attrs:{id:"xml文件配置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#xml文件配置"}},[e._v("#")]),e._v(" xml文件配置")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" \n    xmlns:aop="http://www.springframework.org/schema/aop"\n    xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n    http://www.springframework.org/schema/aop\n                     http://www.springframework.org/schema/aop/spring-aop.xsd">\n\n    <bean id="testAction" class="com.csii.ifp.action.HelloWorld"></bean>\n    <bean id="DamselRescuingKnight" class="com.csii.ifp.action.DamselRescuingKnight">\n        <constructor-arg ref="RunQuest" />\n    </bean>\n    <bean id="BraveQuest" class="com.csii.ifp.action.BraveQuest"></bean>\n    <bean id="RunQuest" class="com.csii.ifp.action.RunQuest"></bean>\n    <bean id="MyMinstrel" class="com.csii.ifp.action.MyMinstrel"></bean>\n\n    <aop:config>\n        <aop:aspect id="my-aspect1" ref="MyMinstrel">\n        \x3c!--定义切点--\x3e\n            <aop:pointcut id="emark" expression="execution(* *.emarkQuest(..))"></aop:pointcut>\n        \x3c!--定义在切点出需要执行的方法--\x3e\n            <aop:before pointcut-ref="emark" method="singBefore"></aop:before>\n            <aop:after pointcut-ref="emark" method="singAfter"></aop:after>\n        </aop:aspect>\n    </aop:config>\n</beans>\n')])])]),t("p",[e._v("这里需要的注意的是，在xml是命名空间里面一定要引入aop的xsd文件。")]),e._v(" "),t("h2",{attrs:{id:"aop的原理-动态代理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#aop的原理-动态代理"}},[e._v("#")]),e._v(" AOP的原理-动态代理")]),e._v(" "),t("p",[e._v("spring的aop采用的_jdk动态代理_，下面是动态代理的简单实现")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('package com.csii.ifp.action;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\npublic class JdkProxyHandler implements InvocationHandler {\n    private Object target;\n    public JdkProxyHandler(Object object) {\n        super()    public\n            ;\n        this.target=object;\n    }\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        Object retVal=null;\n        if (method.getName().equals("emark")) {\n            System.out.println("before invoke handler");\n             retVal=method.invoke(target, args);\n            System.out.println("after invoke handler");\n        }else{\n             retVal=method.invoke(target, args);\n        }\n        return retVal;\n    }\n    public Object getProxy(){\n        return Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), target.getClass().getInterfaces(),this);\n    }\n}\n')])])]),t("p",[e._v("上面实现了一个简单的动态代理处理类，其中的实现的接口InvocationHandler标明的它是一个动态代理。通过")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), target.getClass().getInterfaces(),this)\n")])])]),t("p",[e._v("返回一个所代理的类的实例。下面是具体的使用方法：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("package com.csii.ifp.action;\n\npublic class ProxyTest {\n    public static void main(String[] args) {\n        JdkProxyHandler handler=new JdkProxyHandler(new RunQuest());\n        Quest quest=(Quest) handler.getProxy();\n        quest.emark();\n    }\n}\n")])])]),t("p",[e._v("其中RunQuest是一个具体的实现类，实现了Quest接口。通过把这个类代理给JdkProxyHandler，这样可以使用反射获得一个新的实例，其中所有的方法都会经过代理类的"),t("strong",[e._v("invoke")]),e._v("方法。可以在调用方法时统一做一下特殊的处理。*其中代理类转型的只能是一个接口，这里的原因在下面"),t("a",{attrs:{href:"#jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%8E%9F%E7%90%86"}},[t("em",[e._v("JDK动态代理章节")])]),e._v("会讲到。")]),e._v(" "),t("h3",{attrs:{id:"jdk动态代理的原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jdk动态代理的原理"}},[e._v("#")]),e._v(" jdk动态代理的原理")]),e._v(" "),t("p",[e._v("动态代理涉及的底层方法很多，但是主要的逻辑不是很复杂，需要主要的关注的就是那么几个方法。 首先看构造实例的方法")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("    @CallerSensitive\n static Object newProxyInstance(ClassLoader loader,\n                                          Class<?>[] interfaces,\n                                          InvocationHandler h)\n        throws IllegalArgumentException\n    {\n    //必须传入一个InvocationHandler的接口\n        Objects.requireNonNull(h);\n//克隆出需要代理的接口，作用未知\n        final Class<?>[] intfs = interfaces.clone();\n        //调用者对于这些代理类接口的权限。\n        final SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);\n        }\n\n        /*\n         * Look up or generate the designated proxy class.\n         */\n         //查找或者生成代理类的对象\n        Class<?> cl = getProxyClass0(loader, intfs);\n\n        /*\n         * Invoke its constructor with the designated invocation handler.\n         */\n        try {\n        //检查是否有cl操作的权限\n            if (sm != null) {\n                checkNewProxyPermission(Reflection.getCallerClass(), cl);\n            }\n//通过反射使用构造器生成构造器对象。\n            final Constructor<?> cons = cl.getConstructor(constructorParams);\n            final InvocationHandler ih = h;\n        //如果修饰符不是public的，\n            if (!Modifier.isPublic(cl.getModifiers())) {\n            //访问控制器，可以在run方法中写入需要权限的操作。使得没有权限的操作变成有权限\n                AccessController.doPrivileged(new PrivilegedAction<Void>() {\n                    public Void run() {\n                        cons.setAccessible(true);\n                        return null;\n                    }\n                });\n            }\n            //生成\n            return cons.newInstance(new Object[]{h});\n        } catch (IllegalAccessException|InstantiationException e) {\n            throw new InternalError(e.toString(), e);\n        } catch (InvocationTargetException e) {\n            Throwable t = e.getCause();\n            if (t instanceof RuntimeException) {\n                throw (RuntimeException) t;\n            } else {\n                throw new InternalError(t.toString(), t);\n            }\n        } catch (NoSuchMethodException e) {\n            throw new InternalError(e.toString(), e);\n        }\n    }\n")])])]),t("p",[e._v("其中_CallerSensitive_的作用在于")]),e._v(" "),t("blockquote",[t("p",[e._v("这个注解是为了堵住漏洞用的。曾经有黑客通过构造双重反射来提升权限，原理是当时反射只检查固定深度的调用者的类，看它有没有特权，例如固定看两层的调用者（getCallerClass(2)）。如果我的类本来没足够权限群访问某些信息，那我就可以通过双重反射去达到目的：反射相关的类是有很高权限的，而在 我->反射1->反射2 这样的调用链上，反射2检查权限时看到的是反射1的类，这就被欺骗了，导致安全漏洞。使用CallerSensitive后，getCallerClass不再用固定深度去寻找actual caller（“我”），而是把所有跟反射相关的接口方法都标注上CallerSensitive，搜索时凡看到该注解都直接跳过，这样就有效解决了前面举例的问题")])]),e._v(" "),t("p",[e._v("参照"),t("a",{attrs:{href:"http://blog.csdn.net/hel_wor/article/details/50199797",target:"_blank",rel:"noopener noreferrer"}},[e._v("这里"),t("OutboundLink")],1),e._v(",用处不是很大。 这里主要关注 "),t("em",[e._v("Class cl = getProxyClass0(loader, intfs);* "),t("code",[e._v('java /** * Generate a proxy class. Must call the checkProxyAccess method * to perform permission checks before calling this. */ private static Class<?> getProxyClass0(ClassLoader loader, Class<?>... interfaces) { if (interfaces.length > 65535) { throw new IllegalArgumentException("interface limit exceeded"); } // If the proxy class defined by the given loader implementing // the given interfaces exists, this will simply return the cached copy; // otherwise, it will create the proxy class via the ProxyClassFactory return proxyClassCache.get(loader, interfaces); }')]),e._v(" 可以看到这里校验传入的接口数量不能大于65535，然后直接从缓存中获取代理类,以下是缓存类的实现 "),t("code",[e._v("java /** * a cache of proxy classes */ private static final WeakCache<ClassLoader, Class<?>\\[\\], Class<?>> proxyClassCache = new WeakCache<>(new KeyFactory(), new ProxyClassFactory());")]),e._v(" 通过static保证在初始化时通过*ProxyClassFactory*构造出一个代理类，这是proxy的静态内部类。 "),t("code",[e._v('java /** * A factory function that generates, defines and returns the proxy class given * the ClassLoader and array of interfaces. */ private static final class ProxyClassFactory implements BiFunction<ClassLoader, Class<?>\\[\\], Class<?>> { // prefix for all proxy class names //所有代理类的前缀 private static final String proxyClassNamePrefix = "$Proxy"; // next number to use for generation of unique proxy class names //线程安全的计数器 private static final AtomicLong nextUniqueNumber = new AtomicLong(); @Override public Class<?> apply(ClassLoader loader, Class<?>\\[\\] interfaces) { //这是一个能保证完全相等的map实现。deepEqual Map<Class<?>, Boolean> interfaceSet = new IdentityHashMap<>(interfaces.length); for (Class<?> intf : interfaces) { /* * Verify that the class loader resolves the name of this * interface to the same Class object. */ //使用的类加载器能否构造出相同的接口类 Class<?> interfaceClass = null; try { interfaceClass = Class.forName(intf.getName(), false, loader); } catch (ClassNotFoundException e) { } if (interfaceClass != intf) { throw new IllegalArgumentException( intf + " is not visible from class loader"); } /</em> * Verify that the Class object actually represents an * interface. <em>/ //通过名称和传入的类加载器是否是一个接口 if (!interfaceClass.isInterface()) { throw new IllegalArgumentException( interfaceClass.getName() + " is not an interface"); } /</em> * Verify that this interface is not a duplicate. */ //是否传入了相同的接口 if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) { throw new IllegalArgumentException( "repeated interface: " + interfaceClass.getName()); } } <pre class="prism-highlight line-numbers" data-start="1"><code class="language-null"> String proxyPkg = null; // package to define proxy class in int accessFlags = Modifier.PUBLIC | Modifier.FINAL; /* * Record the package of a non-public proxy interface so that the * proxy class will be defined in the same package. Verify that * all non-public proxy interfaces are in the same package. */ //所有非public的接口必须在同一个包里面 for (Class<?> intf : interfaces) { int flags = intf.getModifiers(); if (!Modifier.isPublic(flags)) { accessFlags = Modifier.FINAL; String name = intf.getName(); int n = name.lastIndexOf(\'.\'); String pkg = ((n == -1) ? "" : name.substring(0, n + 1)); if (proxyPkg == null) { proxyPkg = pkg; } else if (!pkg.equals(proxyPkg)) { throw new IllegalArgumentException( "non-public interfaces from different packages"); } } } </code></pre> //否则采用默认的包名 if (proxyPkg == null) { // if no non-public proxy interfaces, use com.sun.proxy package proxyPkg = ReflectUtil.PROXY\\_PACKAGE + "."; } <pre class="prism-highlight line-numbers" data-start="1"><code class="language-null"> /* * Choose a name for the proxy class to generate. */ //构造代理类的类名 long num = nextUniqueNumber.getAndIncrement(); String proxyName = proxyPkg + proxyClassNamePrefix + num; /* * Generate the specified proxy class. */ //创建代理类 byte\\[\\] proxyClassFile = ProxyGenerator.generateProxyClass( proxyName, interfaces, accessFlags); try { return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length); } catch (ClassFormatError e) { /* * A ClassFormatError here means that (barring bugs in the * proxy class generation code) there was some other * invalid aspect of the arguments supplied to the proxy * class creation (such as virtual machine limitations * exceeded). */ throw new IllegalArgumentException(e.toString()); } } } </code></pre> <pre class="line-numbers prism-highlight" data-start="1"><code class="language-null"><br />通过\\*generateProxyClass\\*建立类的二进制数据，然后调用本地方法生成代理类。 至于invoke是如何被调用的，那是在生成的$procy0.class中对于方法emark(),会首先调用super.invoke()方法，而这个类继承了代理类JdkProxyHandler,实现了Quest接口。 具体参照\\[jdk动态代理中invoke方法调用。\\](http://blog.csdn.net/zcc\\_0015/article/details/22695647) 生成的$proxy0.class类反编译如下')]),e._v(' java package com.sun.proxy; import com.csii.ifp.action.Quest; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; import java.lang.reflect.UndeclaredThrowableException; public final class Proxy0 extends Proxy implements Quest { private static Method m1; private static Method m3; private static Method m2; private static Method m0; public Proxy0() throws { super(paramInvocationHandler); } public final boolean equals() { try { return ((Boolean)this.h.invoke(this, m1, new Object[] { paramObject })).booleanValue(); } catch (RuntimeException localRuntimeException) { throw localRuntimeException; } catch (Throwable localThrowable) { throw new UndeclaredThrowableException(localThrowable); } } public final void emark() throws { try { this.h.invoke(this, m3, null); return; } catch (RuntimeException localRuntimeException) { throw localRuntimeException; } catch (Throwable localThrowable) { throw new UndeclaredThrowableException(localThrowable); } } public final String toString() { try { return ((String)this.h.invoke(this, m2, null)); } catch (RuntimeException localRuntimeException) { throw localRuntimeException; } catch (Throwable localThrowable) { throw new UndeclaredThrowableException(localThrowable); } } public final int hashCode() { try { return ((Integer)this.h.invoke(this, m0, null)).intValue(); } catch (RuntimeException localRuntimeException) { throw localRuntimeException; } catch (Throwable localThrowable) { throw new UndeclaredThrowableException(localThrowable); } } static { try { m1 = Class.forName("java.lang.Object").getMethod("equals", new Class[] { Class.forName("java.lang.Object") }); m3 = Class.forName("com.csii.ifp.action.Quest").getMethod("emark", new Class[0]); m2 = Class.forName("java.lang.Object").getMethod("toString", new Class[0]); m0 = Class.forName("java.lang.Object").getMethod("hashCode", new Class[0]); return; } catch (NoSuchMethodException localNoSuchMethodException) { throw new NoSuchMethodError(localNoSuchMethodException.getMessage()); } catch (ClassNotFoundException localClassNotFoundException) { throw new NoClassDefFoundError(localClassNotFoundException.getMessage()); } } } 至此，jdk动态代理就结束了。')])])])}),[],!1,null,null,null);a.default=r.exports}}]);