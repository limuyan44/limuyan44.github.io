(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{552:function(s,a,t){"use strict";t.r(a);var e=t(6),r=Object(e.a)({},(function(){var s=this,a=s.$createElement,t=s._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("hr"),s._v(" "),t("p",[t("span",{staticStyle:{color:"red","font-size":"25px"}},[s._v("针对于innodb，事务级别为RR")])]),s._v(" "),t("hr"),s._v(" "),t("p",[s._v("innodb实现的是著名的多版本并发控制协议（MVCC）,他的最大好处是读不加锁，这对目前的高并发场景是十分重要的。")]),s._v(" "),t("p",[s._v("分析锁时区分当前读和快照读，快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁。当前读，读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。")]),s._v(" "),t("h3",{attrs:{id:"共享锁-排他锁-s-x"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#共享锁-排他锁-s-x"}},[s._v("#")]),s._v(" 共享锁，排他锁（S,X）")]),s._v(" "),t("ul",[t("li",[t("p",[s._v("**快照读：**简单的select操作，属于快照读，不加锁。")]),s._v(" "),t("ul",[t("li",[s._v("select * from table where ?;")])])]),s._v(" "),t("li",[t("p",[s._v("**当前读：**特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁。")]),s._v(" "),t("ul",[t("li",[s._v("select * from table where ? lock in share mode;")]),s._v(" "),t("li",[s._v("select * from table where ? for update;")]),s._v(" "),t("li",[s._v("insert /update/delete")])]),s._v(" "),t("p",[s._v("所有以上的语句，都属于当前读，读取记录的最新版本。并且，读取之后，还需要保证其他并发事务不能修改当前记录，对读取记录加锁。其中，除了第一条语句，对读取记录加S锁 (共享锁)外，其他的操作，都加的是X锁 (排它锁)。")])])]),s._v(" "),t("h3",{attrs:{id:"间隙锁-gap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#间隙锁-gap"}},[s._v("#")]),s._v(" 间隙锁（GAP）")]),s._v(" "),t("p",[s._v("innodb使用间隙所来解决幻读的问题，不仅在行上加锁，还会在周围加上间隙所来保证可重复读。")]),s._v(" "),t("h3",{attrs:{id:"意向锁-is-ix"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#意向锁-is-ix"}},[s._v("#")]),s._v(" 意向锁（IS,IX）")]),s._v(" "),t("p",[s._v("对于需要获得行锁的事务需要先获得表上面的意向锁。")]),s._v(" "),t("h3",{attrs:{id:"死锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#死锁"}},[s._v("#")]),s._v(" 死锁")]),s._v(" "),t("p",[s._v("死锁的发生与否，并不在于事务中有多少条SQL语句，"),t("strong",[s._v("死锁的关键在于")]),s._v("：两个(或以上)的Session"),t("strong",[s._v("加锁的顺序")]),s._v("不一致。而使用本文上面提到的，分析MySQL每条SQL语句的加锁规则，分析出每条语句的加锁顺序，然后检查多个并发SQL间是否存在以相反的顺序加锁的情况，就可以分析出各种潜在的死锁情况，也可以分析出线上死锁发生的原因。")]),s._v(" "),t("p",[s._v("举一个简单的例子：")]),s._v(" "),t("div",{staticClass:"language-bash line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#session one")]),s._v("\nmysql"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("select")]),s._v(" * from d where "),t("span",{pre:!0,attrs:{class:"token assign-left variable"}},[s._v("a")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(" lock "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("in")]),s._v(" share mode"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#session two")]),s._v("\nupdate d "),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("set")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token assign-left variable"}},[s._v("c")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("  where "),t("span",{pre:!0,attrs:{class:"token assign-left variable"}},[s._v("a")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#session one ")]),s._v("\nupdate d "),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("set")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token assign-left variable"}},[s._v("c")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("  where "),t("span",{pre:!0,attrs:{class:"token assign-left variable"}},[s._v("a")]),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br"),t("span",{staticClass:"line-number"},[s._v("6")]),t("br")])]),t("p",[s._v("发生死锁，原因在于会话一获取了a=1行上的S锁，会话二获取X锁时需要先获取S锁，但是S锁未被释放，因此需要在锁队列中等待，而会话一再次尝试获取X锁，需要等待会话二释放X锁，因此死锁。")]),s._v(" "),t("h3",{attrs:{id:"事物回滚"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#事物回滚"}},[s._v("#")]),s._v(" 事物回滚")]),s._v(" "),t("p",[s._v("mysql的死锁检测到之后，会选择一个事务进行回滚。而选择的依据：看哪个事务的权重最小，事务权重的计算方法：事务加的锁最少；事务写的日志最少；事务开启的时间最晚。")])])}),[],!1,null,null,null);a.default=r.exports}}]);